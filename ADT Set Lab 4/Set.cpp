#include "Set.h"
#include "SetITerator.h"
#include <iostream>

Set::Set() {
	//TODO - Implementation
	this->capacity = 5;
	this->elements = new TElem[this->capacity];
	// setting the empty hashtables values to -1.
	// the deleted position will be marked with -2.
	for(int i = 0; i < this->capacity; i++){
	    this->elements[i] = NULL_TELEM;
	}
    this->generatePrimes();
	this->current_size = 0;
}
// Best case: theta(n) because we have to initialise the elements with NULL_TELEM
// Worst case: theta(n)
// Total complexity: theta(n)

bool Set::add(TElem elem) {

    if(this->current_size == this->capacity){
        this->resize_rehash();
    }

    int i=0, pos = this->hash_function(elem, i);
    while(i < this->capacity && this->elements[pos] != NULL_TELEM && this->elements[pos] != DEL_TELEM){
        i++;
        // if the element is in the hashtable, we exit the function
        if(this->elements[pos] == elem)
            return false;
        pos = this->hash_function(elem, i);
    }

    this->elements[pos] = elem;
//    cout << pos << " " << elem << endl;
    this->current_size++;
	return true;
}
// Best case: theta(1) -> (! no resize/rehash) when the first position returned by the hash function for a specific element is  empty
// Worst case: theta(n) -> when we have to go n times through the loop to get a good value returned by the hash function . Even if we have a resize and rehash, the complexity would still be thetaa(n)
// Total complexity: O(n)

bool Set::remove(TElem elem) {
    int i=0, pos;
    while(i < this->capacity){
        pos = this->hash_function(elem, i);
        i++;
        // if we found an empty position, it means that there are no more elements after.
        if(this->elements[pos] == NULL_TELEM)
            return false;
        // if the element is in the hashtable, we exit the function
        if(this->elements[pos] == elem) {
            this->elements[pos] = DEL_TELEM;
            this->current_size--;
            return true;
        }
    }
	return false;
}
// Best case: theta(1) -> this case is met when the first position generated by the hash function is either ooccupied by the element we seek, or is empty.
// Worst case: theta(n) -> when we have to go n times through the while loop to get the values returned by the hash function for all the probe numbers.
// Total complexity: O(n)

bool Set::search(TElem elem) const {

    int i=0, pos = this->hash_function(elem, i);
    while(i < this->capacity){
        i++;
        // if we found an empty position, it means that there are no more elements after.
        if(this->elements[pos] == NULL_TELEM)
            return false;
        // if the element is in the hashtable, we exit the function
        if(this->elements[pos] == elem)
            return true;
        pos = this->hash_function(elem, i);
    }
	return false;
}
// Best case: theta(1) -> this case is met when the first position generated by the hash function is either ooccupied by the element we seek, or is empty.
// Worst case: theta(n) -> when we have to go n times through the while loop to get the values returned by the hash function for all the probe numbers.
// Total complexity: O(n)

int Set::size() const {
    return this->current_size;
}
// Best case: theta(1)
// Worst case: theta(1)
// Total complexity: theta(1)

bool Set::isEmpty() const {
    return this->current_size == 0;
}
// Best case: theta(1)
// Worst case: theta(1)
// Total complexity: theta(1)

Set::~Set() {
	delete this->elements;
}
// Best case: theta(1)
// Worst case: theta(1)
// Total complexity: theta(1)

SetIterator Set::iterator() const {
	return SetIterator(*this);
}
// Best case: theta(1)
// Worst case: theta(1)
// Total complexity: theta(1)

int Set::hash_function(TElem k,int i) const {
    k = abs(k);
    return (k % this->capacity + i * (1 + (k % (this->capacity - 1)))) % this->capacity;
}
// Best case: theta(1)
// Worst case: theta(1)
// Total complexity: theta(1)

void Set::generatePrimes() {
    this->prime_numbers[0] = 1;
    this->prime_numbers[1] = 1;
    for(int i = 2; i <= 1000; i++){
        if(this->prime_numbers[i] == 0){
            for(int j = i * i; j <= 1000000; j+=i)
                this->prime_numbers[j]= 1;
        }
    }
}
// Best case: theta(n*log(log(n)))
// Worst case: theta(n*log(log(n)))
// Total complexity: theta(n*log(log(n)))

void Set::resize_rehash() {
    int new_capacity = 2 * this->capacity;
    int previous_capacity = this->capacity;
    // we double the current capacity and find the nearest prime number.
    while(this->prime_numbers[new_capacity] == 1)
        new_capacity++;

    this->capacity = new_capacity;
    TElem* new_elements = new TElem[this->capacity];
    for(int i = 0; i < this->capacity; i++){
        new_elements[i] = NULL_TELEM;
    }
    // since we entered the resize function, we are guaranteed that the hashtable is full, which means we dont have to check for empty position
    for(int i = 0 ; i < previous_capacity; i++){
        int j = 0; // probe number

        int pos = this->hash_function(this->elements[i], j);
        while(j < this->capacity && new_elements[pos] != NULL_TELEM && new_elements[pos] != DEL_TELEM){
            j++;
            pos = this->hash_function(this->elements[i], j);
        }
        new_elements[pos] = this->elements[i];
    }

    delete this->elements;
    this->elements = new_elements;
}
// Best case: theta(n) -> [n is the new capacity, a prime number, > 2*m, where m was the previous capacity]the best case would
//                     be when after assigning the new array with the value NULL_TELEM, since the previous
//                     capacity is less than the new one, for every element from the previous array, the hash function would
//                     generate a valid position at the first call.
// Worst case: theta(m ^ 3) -> for sure that the new capacity will be smaller than the square of the previous one. If for all elements, the
//                              hash function would return the same value, for example, when we add an element, it takes this->current_size + 1 steps to add it,
//                              then the complexity of the loops would be m * (1 + 2 + 3 + ... + m) = m * (m^2 + m) / 2 = (m^3 + m^2) / 2
// Total complexity: O(m ^ 3)


